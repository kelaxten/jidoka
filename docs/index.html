<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Assembly Line Manifesto — Jidoka</title>
  <meta name="description" content="On the Industrial Engineering of Agentic Software. A manifesto for applying manufacturing principles to multi-agent software development.">
  <meta property="og:title" content="The Assembly Line Manifesto">
  <meta property="og:description" content="On the Industrial Engineering of Agentic Software. Takt time, standard work, jidoka, kanban, poka-yoke, kaizen — applied to agentic development.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://kelaxten.github.io/jidoka/">
  <meta property="og:site_name" content="Jidoka">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The Assembly Line Manifesto">
  <meta name="twitter:description" content="On the Industrial Engineering of Agentic Software. A manifesto for applying manufacturing principles to multi-agent software development.">
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font-size: 18px;
      scroll-behavior: smooth;
    }

    body {
      background: #0d0f12;
      color: #c8ccd4;
      font-family: Georgia, 'Times New Roman', Times, serif;
      line-height: 1.75;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* --- Hero / Header --- */
    .hero {
      border-bottom: 1px solid #1e2330;
      padding: 4rem 1.5rem 3rem;
      text-align: center;
      background: linear-gradient(180deg, #12151c 0%, #0d0f12 100%);
    }

    .hero h1 {
      font-family: Georgia, 'Times New Roman', Times, serif;
      font-size: 2.6rem;
      font-weight: 700;
      color: #e8ecf2;
      letter-spacing: -0.02em;
      margin-bottom: 0.35rem;
    }

    .hero .subtitle {
      font-size: 1.1rem;
      color: #7a8299;
      font-style: italic;
      margin-bottom: 0.6rem;
    }

    .hero .date {
      font-size: 0.85rem;
      color: #4e5568;
      margin-bottom: 1.2rem;
    }

    .hero .repo-link {
      display: inline-block;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.78rem;
      color: #5b9bd5;
      text-decoration: none;
      border: 1px solid #1e2330;
      padding: 0.4em 1em;
      border-radius: 4px;
      transition: border-color 0.2s, color 0.2s;
    }

    .hero .repo-link:hover {
      color: #8dbde8;
      border-color: #3a4460;
    }

    /* --- Main Content --- */
    .content {
      max-width: 720px;
      margin: 0 auto;
      padding: 3rem 1.5rem 6rem;
    }

    /* --- Headings --- */
    h2 {
      font-family: Georgia, 'Times New Roman', Times, serif;
      font-size: 1.55rem;
      font-weight: 700;
      color: #e8ecf2;
      margin-top: 3.5rem;
      margin-bottom: 1rem;
      letter-spacing: -0.01em;
      line-height: 1.3;
    }

    h3 {
      font-family: Georgia, 'Times New Roman', Times, serif;
      font-size: 1.15rem;
      font-weight: 700;
      color: #d0d5df;
      margin-top: 2.5rem;
      margin-bottom: 0.75rem;
    }

    /* --- Paragraphs --- */
    p {
      margin-bottom: 1.25rem;
    }

    /* --- Emphasis --- */
    em {
      color: #d0d5df;
      font-style: italic;
    }

    strong {
      color: #e8ecf2;
      font-weight: 700;
    }

    /* --- Links --- */
    a {
      color: #5b9bd5;
      text-decoration: underline;
      text-decoration-color: rgba(91, 155, 213, 0.3);
      text-underline-offset: 2px;
      transition: color 0.2s, text-decoration-color 0.2s;
    }

    a:hover {
      color: #8dbde8;
      text-decoration-color: rgba(141, 189, 232, 0.6);
    }

    /* --- Horizontal Rules --- */
    hr {
      border: none;
      border-top: 1px solid #1e2330;
      margin: 2.5rem 0;
    }

    /* --- Blockquotes --- */
    blockquote {
      border-left: 3px solid #3a4460;
      margin: 2.5rem 0;
      padding: 1.25rem 1.5rem;
      background: #11141b;
      border-radius: 0 4px 4px 0;
    }

    blockquote p {
      color: #a8b0c0;
      font-size: 1.05rem;
      margin-bottom: 0;
    }

    blockquote p + p {
      margin-top: 0.75rem;
    }

    blockquote strong {
      color: #d4dae6;
    }

    blockquote em {
      color: #b0b8c8;
    }

    /* The epigraph / pull-quote style for key quotes */
    .pullquote {
      border-left-color: #5b9bd5;
      background: rgba(91, 155, 213, 0.04);
    }

    .pullquote p {
      font-size: 1.1rem;
      color: #b8c4d8;
    }

    .pullquote strong {
      color: #e0e6f0;
    }

    /* --- Code --- */
    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.82em;
      background: #161a24;
      color: #a8d4a0;
      padding: 0.15em 0.4em;
      border-radius: 3px;
      border: 1px solid #1e2330;
    }

    pre {
      margin: 2rem 0;
      padding: 1.5rem;
      background: #0a0c10;
      border: 1px solid #1e2330;
      border-radius: 6px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    pre code {
      background: none;
      border: none;
      padding: 0;
      font-size: 0.78rem;
      line-height: 1.55;
      color: #8a9ab5;
    }

    /* --- Lists --- */
    ul, ol {
      margin-bottom: 1.25rem;
      padding-left: 1.5rem;
    }

    li {
      margin-bottom: 0.35rem;
    }

    /* --- Utility --- */
    .section-break {
      margin: 3rem 0;
    }

    .attribution {
      display: block;
      margin-top: 0.25rem;
      font-size: 0.9rem;
      color: #5a6380;
    }

    .closing-note {
      font-style: italic;
      color: #7a8299;
      margin-top: 2.5rem;
    }

    /* --- Footer --- */
    .footer {
      text-align: center;
      padding: 2rem 1.5rem;
      border-top: 1px solid #1e2330;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.75rem;
      color: #3a4460;
    }

    .footer a {
      color: #4e5568;
    }

    .footer a:hover {
      color: #7a8299;
    }

    /* --- Responsive --- */
    @media (max-width: 600px) {
      html {
        font-size: 16px;
      }

      .hero {
        padding: 3rem 1.25rem 2rem;
      }

      .hero h1 {
        font-size: 1.9rem;
      }

      .content {
        padding: 2rem 1.25rem 4rem;
      }

      h2 {
        font-size: 1.35rem;
      }

      blockquote {
        padding: 1rem 1.15rem;
        margin: 2rem 0;
      }

      pre {
        padding: 1rem;
        border-radius: 4px;
      }

      pre code {
        font-size: 0.72rem;
      }
    }

    @media (max-width: 400px) {
      .hero h1 {
        font-size: 1.6rem;
      }

      pre code {
        font-size: 0.65rem;
      }
    }
  </style>
</head>
<body>

  <header class="hero">
    <h1>The Assembly Line Manifesto</h1>
    <div class="subtitle">On the Industrial Engineering of Agentic Software</div>
    <div class="date">February 2026</div>
    <a href="https://github.com/kelaxten/jidoka" class="repo-link">github.com/kelaxten/jidoka</a>
  </header>

  <main class="content">

    <hr>

    <blockquote>
      <p><em>&ldquo;We can solve any problem by introducing an extra level of indirection&hellip; except for the problem of too many levels of indirection.&rdquo;</em><br>
      <span class="attribution">&mdash; David Wheeler, paraphrased by half the industry</span></p>
    </blockquote>

    <hr>

    <h2>00 &mdash; Preface: The Factory Is Here</h2>

    <p>In January 2026, Steve Yegge launched Gastown and the discourse splintered. Half the industry called it insane. The other half called it inevitable. Both were right.</p>

    <p>Gastown proved something important: you can point twenty Claude Code instances at a codebase and useful work comes out. Not reliable work. Not predictable work. Not work you&rsquo;d bet your production database on. But work. The factory metaphor was no longer theoretical.</p>

    <p>The problem is that Yegge built a frontier town, not a factory. He built a place where a brilliant, experienced developer can wrangle a swarm of autonomous agents through force of will and improvisational skill. It requires what he calls a &ldquo;Stage 7-8 developer&rdquo; &mdash; someone who has already internalized decades of software craft and can pattern-match at the speed the agents produce code.</p>

    <p>This is like saying Ford&rsquo;s assembly line requires a master machinist at every station.</p>

    <p>The whole point of an assembly line is that it doesn&rsquo;t.</p>

    <hr>

    <h2>01 &mdash; Software Has Always Stolen from Manufacturing</h2>

    <p>Every paradigm shift in software development has been borrowed from a manufacturing insight. This is not a coincidence. Manufacturing has spent a century solving the problem of coordinating many workers toward a common output under uncertainty. Software pretends this is a new problem.</p>

    <p>Waterfall came from the sequential assembly line. Requirements first, then design, then build, then test, then ship. Each stage completes before the next begins. It worked for the F-16. It failed for most software because software requirements aren&rsquo;t stable the way an aircraft spec is.</p>

    <p>Agile came from Toyota&rsquo;s lean manufacturing &mdash; small batches, rapid iteration, continuous feedback. Scrum&rsquo;s sprint is a production cycle. The standup is a shift change. The retrospective is a kaizen event. The language was sanitized, but the bones are pure manufacturing.</p>

    <p>DevOps came from continuous flow manufacturing &mdash; the insight that the handoff between &ldquo;people who build&rdquo; and &ldquo;people who deploy&rdquo; is a bottleneck that can be eliminated. CI/CD is literally a production line where code flows from commit to deployment through automated stations.</p>

    <p>Each time, the analogy unlocked something the software industry couldn&rsquo;t see from inside its own frame. Each time, the manufacturing world had solved the problem decades earlier.</p>

    <p>Now we stand at the next transition. AI agents can write code. Multiple agents can write code simultaneously. The question is not whether to use them &mdash; it&rsquo;s how to organize them. And once again, manufacturing has the answer.</p>

    <hr>

    <blockquote class="pullquote">
      <p><strong>The question is not whether agents can write code. It&rsquo;s whether you can build a system where agents writing code produces reliable outcomes.</strong></p>
    </blockquote>

    <hr>

    <h2>02 &mdash; The Gastown Critique</h2>

    <p>Gastown deserves credit. It is the first serious attempt at multi-agent orchestration for software development that actually ships working software. It introduced the Mayor pattern (a coordinator agent), persistent state through Beads, and the concept of agent colonies. These are real contributions.</p>

    <p>But Gastown has five structural problems that an industrial engineering lens immediately exposes.</p>

    <p>First: no standard work. Gastown&rsquo;s agents operate with broad role definitions &mdash; Polecat, Crew, Mayor &mdash; but lack standardized procedures for each task type. In manufacturing, every station has a work instruction sheet that specifies exactly what the worker does, step by step, for each type of input. Gastown has vibes.</p>

    <p>Second: no takt time. There is no rhythm to the line. Agents fire asynchronously with no concept of cycle time, throughput targets, or bottleneck identification. Work accumulates unpredictably. Some agents churn while others starve. The system has no way to detect or resolve this imbalance because it has no concept of flow.</p>

    <p>Third: quality is an afterthought. Yegge himself describes PRs arriving broken and needing manual repair. This is classic end-of-line inspection &mdash; the most expensive form of quality control. Toyota taught us sixty years ago: you build quality into the process at every station. You don&rsquo;t bolt it on at the end.</p>

    <p>Fourth: no Andon cord. When a Gastown agent is stuck, confused, or producing garbage, there is no structured escalation mechanism. The human has to notice, diagnose, and intervene &mdash; if they&rsquo;re watching. The manufacturing equivalent is a factory with no way for a line worker to signal &ldquo;I need help.&rdquo; Toyota solved this in the 1960s with a literal cord any worker could pull to stop the line.</p>

    <p>Fifth: chaos by design. Gastown embraces what Yegge calls &ldquo;nondeterministic infrastructure&rdquo; &mdash; the idea that agents may fail, retry, self-correct, and eventually converge. This is philosophically interesting and practically terrifying. Manufacturing embraces statistical process control: you expect variation, but you engineer it within acceptable bounds. Gastown&rsquo;s variation is unbounded. Sometimes you get four working PRs. Sometimes you get a pile of hot trash. There is no system for telling which you&rsquo;ll get in advance.</p>

    <hr>

    <h2>03 &mdash; The Assembly Line Model</h2>

    <p>We propose something different. Not better &mdash; different. Gastown is an organism. The Assembly Line is a machine. Gastown evolves. The Assembly Line is engineered.</p>

    <p>The model is simple. Software work flows through a fixed sequence of stations. Each station is staffed by a Claude instance following a written work instruction. Each station has a defined input, a defined output, a quality gate, and a mechanism for stopping and escalating when something goes wrong. The human never works on the line. The human designs the line, feeds it requirements, handles escalations, and inspects a sample of outputs.</p>

    <p>That&rsquo;s it. The rest is detail.</p>

    <p>The six stations are: Requirements Intake, Architecture and Design, Implementation, Testing, Code Review, and Integration. Work enters as a raw human request and exits as merged, tested code on the main branch. Each station transforms the work unit and adds a structured artifact &mdash; a spec, a plan, code, tests, a review, a merge.</p>

    <p>Every artifact has a schema. Every handoff has a validation step. If the upstream station produces malformed output, the downstream station cannot accept it. This is the manufacturing principle of poka-yoke &mdash; error-proofing through interface design. You make it physically impossible to pass a defective part to the next station.</p>

<pre><code>HUMAN (Industrial Engineer + Product Owner + Escalation Path)
    |
    | feeds requirements ──────────────── responds to Andon &lt;─┐
    v                                                         |
┌──────────┐   ┌──────────┐   ┌──────────┐                   |
| Station 1 |──&gt;| Station 2 |──&gt;| Station 3 |───┐              |
| Intake    |   | Design   |   | Build    |   |              |
└──────────┘   └──────────┘   └──────────┘   |              |
                                   &lt;── reject ┘              |
┌──────────┐   ┌──────────┐   ┌──────────┐                   |
| Station 6 |&lt;──| Station 5 |&lt;──| Station 4 |───── Andon ────&gt;|
| Merge     |   | Review   |   | Test     |                   |
└────┬─────┘   └──────────┘   └──────────┘                   |
     |                                                        |
     v                                                        |
 [  main  ] ──────────────────────────────────────────────────┘</code></pre>

    <hr>

    <h2>04 &mdash; The Worker and the Engineer</h2>

    <p>Here is the most important idea in this manifesto, and the one that will generate the most resistance:</p>

    <p>The Claude instance is a line worker. It is not a colleague. It is not a junior developer. It is not an agent with autonomy. It is a skilled hand that follows a work instruction. When the instruction is good, the output is good. When the instruction is bad, the output is bad. The intelligence is in the instruction, not in the worker.</p>

    <p>This sounds reductive. It is. That&rsquo;s the point.</p>

    <p>When you treat an agent as a colleague, you expect it to exercise judgment. You expect it to notice when something is off and correct course. You expect it to have taste. Sometimes it does. Often it doesn&rsquo;t. And when it doesn&rsquo;t, you&rsquo;ve shipped a defect that will cost you ten times more to fix downstream than it would have cost to prevent at the station.</p>

    <p>When you treat an agent as a line worker, you invest your intelligence into the work instruction. You specify exactly what the station does, what it checks, when it escalates, and what it does not do. You build the judgment into the process, not the worker. The worker becomes interchangeable. Any Claude instance can staff any station, because the station is fully defined by its work instruction.</p>

    <p>This is the insight that made manufacturing scale. A Ford assembly line worker didn&rsquo;t need to be a master machinist. They needed clear instructions, the right tools, and a foreman who would hear them when they said &ldquo;something&rsquo;s wrong.&rdquo;</p>

    <p>The human is that foreman. More precisely, the human is three things: the industrial engineer who designs the line, the product owner who decides what gets built, and the escalation handler who responds when a station pulls the Andon cord.</p>

    <p>The human never tightens a bolt. The human designs the system that ensures bolts get tightened correctly.</p>

    <hr>

    <blockquote class="pullquote">
      <p><strong>The intelligence is in the instruction, not in the worker. This sounds reductive. It is. That&rsquo;s the point.</strong></p>
    </blockquote>

    <hr>

    <h2>05 &mdash; Six Principles from the Factory Floor</h2>

    <p>Manufacturing has a century of hard-won wisdom about coordinating workers under uncertainty. Six principles translate directly to agentic software development.</p>

    <p><strong>Takt time</strong> is the rhythm of the line &mdash; the pace at which units must move through each station to meet demand. If you need three features per day, your takt time is roughly 2.5 hours per feature. Every station must complete within this window. When a station consistently exceeds takt time, it is a bottleneck. You don&rsquo;t yell at the bottleneck. You add a parallel worker, simplify the work instruction, or break the station into two stations. Measurement replaces intuition.</p>

    <p><strong>Standard work</strong> means every station has a written, versioned, maintained work instruction. These are not guidelines. They are the process. When the worker deviates, it&rsquo;s a defect. When the instruction is wrong, you fix the instruction. The instruction improves through kaizen &mdash; structured, data-driven, continuous improvement &mdash; not through the worker &ldquo;getting better at&rdquo; an ambiguous task.</p>

    <p><strong>Jidoka</strong>, sometimes translated as &ldquo;autonomation&rdquo; or &ldquo;automation with a human touch,&rdquo; means each station has the authority and the obligation to stop and escalate rather than pass defective work downstream. This is the Andon cord. A Claude instance that says &ldquo;I cannot confidently complete this task, here is why, here is what I need&rdquo; is infinitely more valuable than one that guesses and produces something that looks right but isn&rsquo;t. The key insight of jidoka is that stopping the line is not a failure. Passing a defect downstream is.</p>

    <p><strong>Kanban</strong>, the pull system, means downstream stations pull work when they have capacity, rather than upstream stations pushing work when they finish. This prevents the work-in-progress explosion that is Gastown&rsquo;s primary failure mode &mdash; twenty agents churning simultaneously on tasks that nobody is ready to review, test, or integrate. Each station has a WIP limit. When the limit is reached, the upstream station waits. This feels slow. It is faster. Always.</p>

    <p><strong>Poka-yoke</strong>, error-proofing, means designing the interfaces between stations so that malformed work physically cannot pass through. If Station 1&rsquo;s output is missing acceptance criteria, Station 2&rsquo;s input validation rejects it automatically. No human needs to notice. No agent needs to exercise judgment. The interface enforces correctness. This is the manufacturing equivalent of type systems, and it is equally underappreciated.</p>

    <p><strong>Kaizen</strong>, continuous improvement, means the line gets better every cycle. Not because the workers get smarter &mdash; they&rsquo;re stateless. Because the work instructions get better. Every Andon pull generates a work instruction update. Every defect found at Station 4 or 5 generates a quality gate improvement at Station 1, 2, or 3. The feedback loop is explicit, measured, and relentless.</p>

    <hr>

    <h2>06 &mdash; The Andon Cord Is the Whole Thing</h2>

    <p>If you take one idea from this manifesto, take this one: the Andon cord is the entire system.</p>

    <p>Every other mechanism &mdash; the stations, the work instructions, the quality gates, the Kanban limits &mdash; exists to support one capability: the ability of a worker to say &ldquo;I&rsquo;m stuck&rdquo; in a structured way, and the ability of the system to route that signal to a human who can resolve it and update the process so it doesn&rsquo;t happen again.</p>

    <p>In Gastown, when an agent gets stuck, it does one of three things. It guesses and proceeds. It silently fails. Or the human notices and intervenes. Two of these three outcomes are bad. The third depends on the human being attentive, which is a poor engineering assumption.</p>

    <p>In the Assembly Line, getting stuck is a first-class operation. Every station has defined Andon triggers &mdash; specific conditions under which the worker must stop and escalate. Not &ldquo;when you feel confused.&rdquo; Not &ldquo;when something seems wrong.&rdquo; Specific, enumerated conditions:</p>

    <p>Station 1 pulls the cord when requirements are ambiguous, when the request conflicts with existing behavior, or when the request has security implications that require human judgment.</p>

    <p>Station 3 pulls the cord when the implementation plan is infeasible, when a dependency doesn&rsquo;t exist, or when a discovered bug in existing code isn&rsquo;t accounted for in the plan.</p>

    <p>Station 5 pulls the cord when it finds a security vulnerability that may exist in production, or when it discovers the spec itself is flawed.</p>

    <p>The Andon report is structured: station ID, unit ID, trigger condition, context, and a specific question for the human. Not &ldquo;help, I&rsquo;m stuck.&rdquo; A specific, answerable question.</p>

    <p>And here is the discipline that makes the whole system work: every Andon resolution must result in a work instruction update. If the human answers the same question twice, the line has a design defect. The question should have been anticipated and the answer should have been in the work instruction. The goal is not zero Andon pulls &mdash; that would mean the workers are guessing instead of asking. The goal is zero repeat Andon pulls. The line learns through its escalations, even though the workers are stateless.</p>

    <hr>

    <blockquote class="pullquote">
      <p><strong>Every Andon resolution must result in a work instruction update. If you answer the same question twice, your line has a design defect.</strong></p>
    </blockquote>

    <hr>

    <h2>07 &mdash; Why Separation of Concerns Is Not Optional</h2>

    <p>The Assembly Line has six stations, not one. This is not bureaucracy. It is the most important structural decision in the system.</p>

    <p>The agent that writes the code must not be the agent that tests the code. The agent that designs the implementation must not be the agent that reviews it. The agent that decomposes the requirements must not be the agent that decides the architecture. Each station has a different concern, a different context window, and a different adversarial relationship with the others.</p>

    <p>Station 4, Testing, is adversarial to Station 3, Implementation. Its job is to find defects. If the same agent writes and tests code, it will test the code it wrote, which means it will test its own assumptions. It will write tests that confirm what it believes the code does, not tests that challenge what the code actually does. This is not a theoretical concern. This is the single most common failure mode in AI-generated code today.</p>

    <p>Station 5, Code Review, is adversarial to both Station 2 and Station 3. It evaluates whether the design was sound and the implementation was faithful. It has fresh eyes &mdash; a different context window that was not polluted by the design process or the implementation struggle. It can see what the implementer cannot: the forest.</p>

    <p>This separation also solves the context window problem. A Claude instance doing requirements decomposition does not need the codebase in its context. A Claude instance doing implementation does not need the product strategy in its context. Each station loads only the context it needs &mdash; the work instruction, the input artifacts, and the relevant code. This is not just efficient. It produces better outputs, because the worker is not distracted by irrelevant information.</p>

    <p>In manufacturing, this principle is ancient: the person who assembles a part does not inspect it. The person who designs a process does not operate it. The person who operates does not maintain. Each role has a different concern, a different skill set, and a different adversarial relationship with the others. This separation is what makes quality possible at scale.</p>

    <hr>

    <h2>08 &mdash; The Gold-Plating Rule</h2>

    <p>Station 3&rsquo;s work instruction contains what we call the Gold-Plating Rule, and it deserves its own section because it addresses the single most expensive failure mode in agentic development.</p>

    <p>The rule is: if, during implementation, the worker thinks &ldquo;this would be better if I also...&rdquo; &mdash; that thought is a new unit for Station 1. It is not scope creep. It is not initiative. It is a defect in process discipline. The worker writes the suggestion in a notes field and moves on.</p>

    <p>This sounds rigid. It is rigid. Here&rsquo;s why.</p>

    <p>When a human developer sees something that could be improved while implementing a feature, they use judgment. They weigh the cost of the detour against the benefit. They consider whether the improvement is worth the added review burden. They make a decision that accounts for context they have accumulated over months or years of working in this codebase.</p>

    <p>A Claude instance does not have this judgment. It has a context window and a strong prior toward being helpful. &ldquo;Being helpful&rdquo; to a Claude instance means doing more, doing better, making things nicer. This is exactly the instinct that produces the &ldquo;pile of hot trash&rdquo; Yegge describes &mdash; agents that race ahead, adding features nobody asked for, refactoring code they happened to notice, introducing abstractions &ldquo;for future use,&rdquo; and burning tokens on improvements that may or may not align with the product direction.</p>

    <p>The Gold-Plating Rule eliminates this failure mode mechanically. The worker cannot gold-plate because the work instruction explicitly prohibits it. The improvement isn&rsquo;t lost &mdash; it&rsquo;s captured as a note that becomes a candidate unit in the backlog. The human decides if and when to build it. The agent builds what was designed, nothing more, nothing less.</p>

    <p>This is why the Assembly Line works for developers who are not Yegge-level Stage 7-8 operators. The discipline is in the system, not in the human&rsquo;s ability to detect and correct agent runaway in real time.</p>

    <hr>

    <h2>09 &mdash; You Are Not Training the Agents</h2>

    <p>Here is the fundamental insight, the one that makes everything else click:</p>

    <p>You are not training the agents. You are engineering the process.</p>

    <p>The Claude instances are stateless. They learn nothing between sessions. They carry no memory of the last unit they processed. They are interchangeable commodity workers. You could swap one for another mid-stream and the line would not notice, because the state is in the work unit, not in the worker.</p>

    <p>This is a feature, not a limitation.</p>

    <p>When you try to make agents smarter &mdash; through elaborate system prompts, through fine-tuning, through multi-turn conversations where you build up context and rapport &mdash; you are investing in the worker. This investment evaporates with every new session. Every token you spend making an agent &ldquo;understand&rdquo; your codebase is a token you will spend again tomorrow.</p>

    <p>When you invest in the line instead &mdash; better work instructions, tighter quality gates, more specific Andon triggers, more structured handoffs &mdash; the investment persists. The work instructions are files in your repository. They are versioned. They are reviewed. They improve monotonically over time, because every defect found downstream results in an upstream improvement.</p>

    <p>This is how manufacturing scaled. Ford didn&rsquo;t build better machinists. He built a better line and staffed it with the machinists he had. Toyota didn&rsquo;t hire geniuses for the factory floor. They built a system where ordinary workers could produce extraordinary quality, because the system caught errors that human judgment would miss.</p>

    <p>The Assembly Line does the same for agentic software development. The intelligence is in the line. The workers are replaceable. The human is the engineer.</p>

    <hr>

    <blockquote class="pullquote">
      <p><strong>You are not training the agents. You are engineering the process. The investment in better work instructions persists. The investment in smarter agents evaporates every session.</strong></p>
    </blockquote>

    <hr>

    <h2>10 &mdash; How to Begin</h2>

    <p>Start with single-piece flow. One unit. All six stations. Sequential. No parallelism.</p>

    <p>This will feel painfully slow. One feature, processed through six separate Claude Code sessions, with structured handoffs and quality gates at each boundary. You will be tempted to skip stations, to combine them, to &ldquo;just let Claude handle it.&rdquo; Resist.</p>

    <p>Single-piece flow is how you debug the line. You will discover that your Station 1 work instruction doesn&rsquo;t produce specs detailed enough for Station 2. You will discover that Station 2 sometimes defers design decisions to Station 3 with a &ldquo;TBD.&rdquo; You will discover that Station 5 flags issues that should have been caught by Station 3&rsquo;s quality gate. Each discovery is a work instruction improvement.</p>

    <p>After five to ten units, your line will be tuned. The work instructions will be specific. The quality gates will catch real defects. The Andon triggers will fire at the right moments. You will have data &mdash; average cycle time per station, first-pass yield, defect distribution, Andon frequency.</p>

    <p>Then add parallelism. Put a second Claude Code instance at Station 3, your bottleneck. Then a second at Station 4. Watch the throughput increase without a corresponding increase in defect rate, because the quality is in the process, not the workers.</p>

    <p>Then run multiple units simultaneously. Kanban limits prevent overload. Each unit flows independently. Your role shifts from &ldquo;person doing the work&rdquo; to &ldquo;person monitoring the board, responding to Andons, and improving the line.&rdquo;</p>

    <p>Then build specialized lines. A fast lane for bug fixes that skips the architecture station. A heavyweight lane for new features that adds an extra review. Route work to the appropriate line based on type and risk.</p>

    <p>Then establish the kaizen loop. Weekly, review the metrics. Which station had the most Andon pulls? Which quality gate caught the most defects? Where did cycle time spike? Adjust one work instruction per week. Measure the impact. Iterate.</p>

    <p>The line gets better every week because the instructions get better, not because the workers get smarter. This is the fundamental advantage of engineered systems over improvisational ones. Improvisation has a ceiling. Engineering has a ramp.</p>

    <hr>

    <h2>11 &mdash; What We Believe</h2>

    <p>We believe that agentic software development is real, and that it works, and that it is here to stay.</p>

    <p>We believe that the way to make it reliable is not to build smarter agents, but to build better systems around the agents we have.</p>

    <p>We believe that a century of manufacturing science &mdash; takt time, standard work, jidoka, kanban, poka-yoke, kaizen &mdash; applies directly to the problem of coordinating AI workers, and that the software industry&rsquo;s reluctance to learn from manufacturing is an expensive blind spot.</p>

    <p>We believe that the human&rsquo;s highest-leverage contribution is designing the process, not performing the work. Every hour spent improving a work instruction saves a hundred hours of agent supervision.</p>

    <p>We believe that quality must be built into every station, not inspected at the end. End-of-line inspection is the most expensive form of quality control. Building quality in is the cheapest.</p>

    <p>We believe that structured escalation &mdash; the Andon cord &mdash; is more valuable than agent autonomy. An agent that stops and asks is more valuable than an agent that guesses and ships.</p>

    <p>We believe that agents are interchangeable commodity workers, and that this is a feature. The intelligence is in the line. The workers are stateless. The process is persistent.</p>

    <p>We believe that the Gold-Plating Rule &mdash; do what was designed, nothing more &mdash; is essential to preventing the runaway token burn and scope creep that plague autonomous agent systems.</p>

    <p>We believe that this approach makes agentic development accessible to developers who are not Stage 7-8 operators. You don&rsquo;t need twenty years of experience to follow a work instruction or pull an Andon cord. You need a well-designed line.</p>

    <p>We believe that Gastown pointed in the right direction. The factory metaphor is correct. The execution needs engineering.</p>

    <p>We believe that the Assembly Line is that engineering.</p>

    <hr>

    <p class="closing-note">The Assembly Line is open source. The work instructions are markdown files. The controller is a zero-dependency Node.js script. The ideas are borrowed from Toyota, Ford, Ohno, Deming, and Shingo. The implementation is new. The need is now.</p>

  </main>

  <footer class="footer">
    <a href="https://github.com/kelaxten/jidoka">jidoka</a> &mdash; the assembly line for agentic software
  </footer>

</body>
</html>
